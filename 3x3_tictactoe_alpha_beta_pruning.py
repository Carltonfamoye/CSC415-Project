# -*- coding: utf-8 -*-
"""3x3 TicTacToe

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dxSOFHap04F2sIQsuInmjtutdufej99C
"""

from treelib import Node, Tree
import copy
import random
import time
import numpy as np


class Tictoe:
    def __init__(self, size):
        self.size = size
        self.board = np.zeros(size*size)
        self.letters_to_move = ['a', 'b', 'c', 'd',
                                'e', 'f', 'g', 'h', 'i'][:size*size]

    def get_board(self):
        return self.board.reshape([self.size, self.size])

    def make_move(self, who, where, verbose=False):
        self.board[self.letters_to_move.index(where)] = who

    def get_sums_of_board(self):
        local_board = self.get_board()
        return np.concatenate([local_board.sum(axis=0),             # columns
                               local_board.sum(axis=1),             # rows
                               np.trace(local_board),               # diagonal
                               np.trace(np.fliplr(local_board))], axis=None)   # other diagonal

    def is_endstate(self):
        someone_won = len(np.intersect1d(
            (self.size, -self.size), self.get_sums_of_board())) > 0
        draw = np.count_nonzero(self.board) == self.size * self.size

        if np.count_nonzero(self.board) < 5: # don't check win state if five moves haven't been played
            return False
        elif someone_won:
            return someone_won
        else:
            return draw

    def get_value(self):
        sums = self.get_sums_of_board()
        if self.size in sums:
            return 10 - np.count_nonzero(self.board)   # Punish longer games
        elif -self.size in sums:
            return -10 + np.count_nonzero(self.board)
        else:
            return 0


def remove_value_list(l, val):
    return [el for el in l if el != val]


flip_player = {1: -1, -1: 1}

possible_options = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']


def add_options_to_node(tree, node, tt_data, player, remaining_options):
    for option in remaining_options:
        # To prevent changing these values in other branches of the tree
        local_tt_data = copy.deepcopy(tt_data)
        local_tt_data.make_move(player, option, False)
        if node.identifier != 'root':
            new_identifier = node.identifier + option
        else:
            new_identifier = option
        tree.create_node(option, new_identifier,
                         node.identifier, data=local_tt_data)
        # At end of the game, stop adding nodes
        if len(remaining_options) > 1 and not local_tt_data.is_endstate():
            add_options_to_node(tree, tree[new_identifier], local_tt_data,
                                flip_player[player], remove_value_list(remaining_options, option))
    return None

# TODO Make minimax tree generation faster


TicToe_state = Tictoe(3)
TicToe_3x3 = Tree()
start = time.time()
TicToe_3x3.create_node("root", "root")
add_options_to_node(TicToe_3x3, TicToe_3x3["root"],
                    TicToe_state, 1, possible_options)
print(time.time()-start)

MAX, MIN = 1000, -1000


def minmax_tt(tree, current_id, is_max, alpha, beta):
    current_node = tree[current_id]
    if current_node.data.is_endstate():
        return current_node.data.get_value()

    # alpha-beta pruning
    if is_max:                                          # Return the max or min score depending on which player we are
        best = MIN
        children_of_current_id = tree.children(current_id)
        for child in children_of_current_id:            # iterate over each child of the current node
            scores = [minmax_tt(tree, child.identifier,
                                not is_max, alpha, beta)]
            best = max(best, max(scores))
            alpha = max(alpha, best)

            if beta <= alpha:
                break
        return best
    else:
        best = MAX
        children_of_current_id = tree.children(current_id)
        for child in children_of_current_id:
            scores = [minmax_tt(tree, child.identifier,
                                not is_max, alpha, beta)]

            best = min(best, max(scores))
            beta = min(beta, best)

            if beta <= alpha:
                break

        return best


def determine_move(tree, current_id, is_max):
    '''
    Given a state on the board, what is the best next move? 
    '''
    potential_moves = tree.children(current_id)
    moves = [child.identifier[-1] for child in potential_moves]
    raw_scores = np.array(
        [minmax_tt(tree, child.identifier, not is_max, MIN, MAX) for child in potential_moves])
    if is_max:
        return moves[random.choice(np.where(raw_scores == max(raw_scores))[0])]
    else:
        return moves[random.choice(np.where(raw_scores == min(raw_scores))[0])]


tictactoe = Tictoe(3)

print('''Welcome to TicTacToe. 

You can make a move by selecting one of the following letters:''')
print(np.array(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']).reshape(3, 3))
print('''You start, the computer will take the next move

Initial board:''')

move_history = ''
while not tictactoe.is_endstate():
    player_move = input('Your move!: ')
    tictactoe.make_move(1, player_move)
    print(tictactoe.get_board())
    move_history += player_move
    if tictactoe.is_endstate():
        print('You won!...wait you won?????')
        break

    start = time.time()
    print('Computer is thinking')
    computer_move = determine_move(TicToe_3x3, move_history, False)
    tictactoe.make_move(-1, computer_move)
    print(time.time()-start)

    print(tictactoe.get_board())
    move_history += computer_move
    if tictactoe.is_endstate():
        print('Computer won!')

    if len(move_history) >= 8 and not tictactoe.is_endstate():
        print('Draw...')
        break
